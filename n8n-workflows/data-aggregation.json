{
  "name": "Data Aggregation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "aggregate",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "data-aggregation"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.SUPABASE_URL}}/rest/v1/rpc/check_rate_limit_sliding",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "multipleHttpHeadersAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\"p_identifier\": \"data_aggregation_worker\", \"p_limit_count\": 30, \"p_window_seconds\": 60}",
        "options": {}
      },
      "id": "check-rate-limit",
      "name": "Check Rate Limit",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [470, 300],
      "credentials": {
        "multipleHttpHeadersAuth": {
          "id": "supabase-headers",
          "name": "Supabase Headers Auth"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-allowed",
              "leftValue": "={{ $json.allowed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "rate-limit-check",
      "name": "Rate Limit OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [690, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: 'rate_limit_exceeded', message: 'Data Aggregation worker rate limit exceeded. Please wait before retrying.', retry_after_seconds: 60 }) }}",
        "options": {
          "responseCode": 429
        }
      },
      "id": "rate-limited-response",
      "name": "Rate Limited Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [910, 500]
    },
    {
      "parameters": {
        "jsCode": "// Parse incoming results from parallel tasks\nconst items = $input.all();\nconst results = [];\nconst startTime = Date.now();\n\nfor (const item of items) {\n  const body = item.json.body || item.json;\n  \n  results.push({\n    json: {\n      aggregation_id: body.aggregation_id || 'agg_' + Date.now(),\n      results: body.results || [],\n      user_id: body.user_id || null,\n      aggregation_type: body.type || 'merge',\n      options: body.options || {},\n      _start_time: startTime\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "parse-input",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [910, 200]
    },
    {
      "parameters": {
        "jsCode": "// Merge results from parallel processing\nconst items = $input.all();\nconst output = [];\n\nfor (const item of items) {\n  const results = item.json.results;\n  const options = item.json.options;\n  \n  if (results.length === 0) {\n    output.push({ json: { ...item.json, merged_data: {}, conflicts: [], provenance: [] } });\n    continue;\n  }\n  \n  const merged = {};\n  const conflicts = [];\n  const provenance = [];\n  \n  for (let i = 0; i < results.length; i++) {\n    const result = results[i];\n    const data = result.extracted_data || result.data || result;\n    \n    for (const [key, value] of Object.entries(data)) {\n      if (merged[key] === undefined) {\n        merged[key] = value;\n        provenance.push({ field: key, source_index: i, value });\n      } else if (JSON.stringify(merged[key]) !== JSON.stringify(value)) {\n        // Conflict detected\n        conflicts.push({\n          field: key,\n          existing_value: merged[key],\n          existing_source: provenance.find(p => p.field === key)?.source_index,\n          new_value: value,\n          new_source: i\n        });\n        \n        // Resolution strategy based on options\n        if (options.conflict_resolution === 'latest') {\n          merged[key] = value;\n          provenance.push({ field: key, source_index: i, value, resolved: true });\n        } else if (options.conflict_resolution === 'highest_confidence') {\n          const existingConfidence = results[provenance.find(p => p.field === key)?.source_index]?.confidence || 0;\n          const newConfidence = result.confidence || 0;\n          if (newConfidence > existingConfidence) {\n            merged[key] = value;\n            provenance.push({ field: key, source_index: i, value, resolved: true });\n          }\n        }\n      }\n    }\n  }\n  \n  output.push({\n    json: {\n      ...item.json,\n      merged_data: merged,\n      conflicts,\n      provenance\n    }\n  });\n}\n\nreturn output;"
      },
      "id": "merge-results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1130, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-has-conflicts",
              "leftValue": "={{ $json.conflicts.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "has-conflicts",
      "name": "Has Conflicts?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1350, 200]
    },
    {
      "parameters": {
        "jsCode": "// Prepare OpenAI payload for conflict resolution\nconst items = $input.all();\nconst results = [];\n\nconst systemPrompt = `You are a data reconciliation expert. Analyze the conflicting values and recommend the best resolution.\n\nRespond ONLY with valid JSON:\n{\n  \"resolutions\": [\n    {\n      \"field\": \"field_name\",\n      \"recommended_value\": \"value\",\n      \"confidence\": 0.9,\n      \"reasoning\": \"explanation\"\n    }\n  ],\n  \"needs_manual_review\": false\n}`;\n\nfor (const item of items) {\n  const data = item.json;\n  \n  results.push({\n    json: {\n      ...data,\n      openai_payload: {\n        model: 'gpt-4o-mini',\n        messages: [\n          { role: 'system', content: systemPrompt },\n          { role: 'user', content: `Resolve these data conflicts:\\n\\n${JSON.stringify(data.conflicts)}\\n\\nContext from merged data:\\n${JSON.stringify(data.merged_data)}` }\n        ],\n        max_tokens: 1024,\n        temperature: 0.1\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "prepare-resolution-payload",
      "name": "Prepare Resolution Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1570, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.openai_payload) }}",
        "options": {
          "retry": {
            "maxTries": 3,
            "retryInterval": 1000,
            "retryIntervalUnit": "milliseconds",
            "backoffFactor": 2,
            "retryOn": "statusCodes",
            "statusCodesToRetry": "429,500,502,503,504"
          },
          "timeout": 120000
        }
      },
      "id": "resolve-conflicts",
      "name": "AI Conflict Resolution",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1790, 100],
      "credentials": {
        "httpHeaderAuth": {
          "id": "openai-credential",
          "name": "OpenAI API Key"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Apply AI resolutions\nconst items = $input.all();\nconst prevItems = $('Prepare Resolution Payload').all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  const inputData = prevItems[i].json;\n  \n  let resolutions;\n  try {\n    let text = item.json.choices?.[0]?.message?.content || '{}';\n    if (text.includes('```json')) {\n      text = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '');\n    } else if (text.includes('```')) {\n      text = text.replace(/```\\n?/g, '');\n    }\n    resolutions = JSON.parse(text.trim());\n  } catch (e) {\n    resolutions = { resolutions: [], needs_manual_review: true };\n  }\n  \n  // Apply resolutions to merged data\n  const finalData = { ...inputData.merged_data };\n  for (const resolution of resolutions.resolutions || []) {\n    if (resolution.confidence >= 0.7) {\n      finalData[resolution.field] = resolution.recommended_value;\n    }\n  }\n  \n  results.push({\n    json: {\n      ...inputData,\n      final_data: finalData,\n      ai_resolutions: resolutions,\n      needs_manual_review: resolutions.needs_manual_review || false\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "apply-resolutions",
      "name": "Apply Resolutions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2010, 0]
    },
    {
      "parameters": {
        "jsCode": "// Handle OpenAI error - mark for manual review\nconst items = $input.all();\nconst prevItems = $('Prepare Resolution Payload').all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const inputData = prevItems[i]?.json || items[i].json;\n  \n  results.push({\n    json: {\n      ...inputData,\n      final_data: inputData.merged_data,\n      ai_resolutions: null,\n      needs_manual_review: true,\n      error: 'AI conflict resolution failed'\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "handle-ai-error",
      "name": "Handle AI Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2010, 200]
    },
    {
      "parameters": {
        "jsCode": "// No conflicts - pass through\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  results.push({\n    json: {\n      ...item.json,\n      final_data: item.json.merged_data,\n      ai_resolutions: null,\n      needs_manual_review: false\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "no-conflicts",
      "name": "No Conflicts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1570, 300]
    },
    {
      "parameters": {
        "jsCode": "// Cross-validate aggregated data\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json.final_data;\n  const sourceResults = item.json.results;\n  \n  const validationResults = [];\n  \n  for (const [field, value] of Object.entries(data)) {\n    const sourceValues = sourceResults\n      .map(r => (r.extracted_data || r.data || r)[field])\n      .filter(v => v !== undefined);\n    \n    const uniqueValues = [...new Set(sourceValues.map(v => JSON.stringify(v)))];\n    \n    validationResults.push({\n      field,\n      final_value: value,\n      source_count: sourceValues.length,\n      unique_values: uniqueValues.length,\n      consistency: uniqueValues.length === 1 ? 1 : 1 / uniqueValues.length\n    });\n  }\n  \n  const avgConsistency = validationResults.length > 0 ?\n    validationResults.reduce((sum, v) => sum + v.consistency, 0) / validationResults.length : 1;\n  \n  results.push({\n    json: {\n      ...item.json,\n      cross_validation: {\n        results: validationResults,\n        average_consistency: avgConsistency,\n        passed: avgConsistency >= 0.7\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "cross-validate",
      "name": "Cross Validation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2230, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-validation-passed",
              "leftValue": "={{ $json.cross_validation.passed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "validation-check",
      "name": "Validation Passed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2450, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.SUPABASE_URL}}/rest/v1/worker_metrics",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "multipleHttpHeadersAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ worker_name: 'data_aggregation', metric_type: 'task_success', value: Date.now() - $json._start_time, tags: { task_id: $json.aggregation_id, sources_count: $json.results.length, conflicts_count: $json.conflicts.length, consistency_score: $json.cross_validation.average_consistency, needs_manual_review: $json.needs_manual_review } }) }}",
        "options": {}
      },
      "id": "log-success-metric",
      "name": "Log Success Metric",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2670, 100],
      "credentials": {
        "multipleHttpHeadersAuth": {
          "id": "supabase-headers",
          "name": "Supabase Headers Auth"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, aggregation_id: $('Cross Validation').first().json.aggregation_id, final_data: $('Cross Validation').first().json.final_data, conflicts_resolved: $('Cross Validation').first().json.conflicts.length, consistency_score: $('Cross Validation').first().json.cross_validation.average_consistency, needs_manual_review: $('Cross Validation').first().json.needs_manual_review, provenance: $('Cross Validation').first().json.provenance }) }}"
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2890, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.SUPABASE_URL}}/rest/v1/worker_metrics",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "multipleHttpHeadersAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ worker_name: 'data_aggregation', metric_type: 'task_failure', value: Date.now() - $json._start_time, tags: { task_id: $json.aggregation_id, sources_count: $json.results.length, conflicts_count: $json.conflicts.length, consistency_score: $json.cross_validation.average_consistency, error: 'Cross validation failed - low consistency score' } }) }}",
        "options": {}
      },
      "id": "log-failure-metric",
      "name": "Log Failure Metric",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2670, 300],
      "credentials": {
        "multipleHttpHeadersAuth": {
          "id": "supabase-headers",
          "name": "Supabase Headers Auth"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.SUPABASE_URL}}/rest/v1/dead_letter_queue",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "multipleHttpHeadersAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ task_type: 'data_aggregation', task_payload: { aggregation_id: $json.aggregation_id, results: $json.results, options: $json.options, user_id: $json.user_id }, error_message: 'Cross validation failed - consistency score: ' + $json.cross_validation.average_consistency, retry_count: 0, max_retries: 3 }) }}",
        "options": {}
      },
      "id": "send-to-dlq",
      "name": "Send to DLQ",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2890, 300],
      "credentials": {
        "multipleHttpHeadersAuth": {
          "id": "supabase-headers",
          "name": "Supabase Headers Auth"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "fromEmail": "={{$env.ALERT_EMAIL}}",
        "toEmail": "={{$env.ALERT_EMAIL}}",
        "subject": "=Data Aggregation Alert: Validation Failed - {{ $json.aggregation_id }}",
        "emailType": "html",
        "html": "=<h2>Data Aggregation Validation Failed</h2><p><strong>Aggregation ID:</strong> {{ $json.aggregation_id }}</p><p><strong>Consistency Score:</strong> {{ $json.cross_validation.average_consistency }}</p><p><strong>Sources Count:</strong> {{ $json.results.length }}</p><p><strong>Conflicts Count:</strong> {{ $json.conflicts.length }}</p><p><strong>Needs Manual Review:</strong> {{ $json.needs_manual_review }}</p><p>This task has been sent to the Dead Letter Queue for retry.</p>",
        "options": {}
      },
      "id": "send-alert-email",
      "name": "Send Alert Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [3110, 300],
      "credentials": {
        "smtp": {
          "id": "smtp-credential",
          "name": "SMTP Gmail"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: 'validation_failed', aggregation_id: $('Cross Validation').first().json.aggregation_id, consistency_score: $('Cross Validation').first().json.cross_validation.average_consistency, message: 'Data aggregation failed cross-validation. Task sent to DLQ for retry.', needs_manual_review: true }) }}",
        "options": {
          "responseCode": 422
        }
      },
      "id": "failure-response",
      "name": "Failure Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3330, 300]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Check Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Rate Limit": {
      "main": [
        [
          {
            "node": "Rate Limit OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit OK?": {
      "main": [
        [
          {
            "node": "Parse Input",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Rate Limited Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Input": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Has Conflicts?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Conflicts?": {
      "main": [
        [
          {
            "node": "Prepare Resolution Payload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Conflicts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Resolution Payload": {
      "main": [
        [
          {
            "node": "AI Conflict Resolution",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Conflict Resolution": {
      "main": [
        [
          {
            "node": "Apply Resolutions",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle AI Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Resolutions": {
      "main": [
        [
          {
            "node": "Cross Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle AI Error": {
      "main": [
        [
          {
            "node": "Cross Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Conflicts": {
      "main": [
        [
          {
            "node": "Cross Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cross Validation": {
      "main": [
        [
          {
            "node": "Validation Passed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation Passed?": {
      "main": [
        [
          {
            "node": "Log Success Metric",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Failure Metric",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Success Metric": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Failure Metric": {
      "main": [
        [
          {
            "node": "Send to DLQ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to DLQ": {
      "main": [
        [
          {
            "node": "Send Alert Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Alert Email": {
      "main": [
        [
          {
            "node": "Failure Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "pinData": {}
}
