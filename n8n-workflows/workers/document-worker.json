{
  "name": "Document Worker",
  "nodes": [
    {
      "parameters": {
        "values": {
          "values": [
            {
              "name": "task",
              "value": "={{ $execution.customData.task || '{}' }}"
            }
          ]
        }
      },
      "id": "input",
      "name": "Workflow Input",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse task and prepare for multi-format processing\nconst taskStr = $input.item.json.task || '{}';\nlet task;\ntry {\n  task = typeof taskStr === 'string' ? JSON.parse(taskStr) : taskStr;\n} catch (e) {\n  task = taskStr;\n}\n\nconst payload = task.payload || task;\nconst files = Array.isArray(payload) ? payload : [payload];\n\nreturn files.map((file, index) => {\n  // Detect file type from mime_type or filename\n  const mimeType = file.mime_type || '';\n  const filename = file.filename || '';\n  \n  let fileType = 'image';\n  if (mimeType.includes('pdf') || filename.endsWith('.pdf')) {\n    fileType = 'pdf';\n  } else if (mimeType.includes('tiff') || filename.endsWith('.tiff') || filename.endsWith('.tif')) {\n    fileType = 'tiff';\n  }\n  \n  return {\n    json: {\n      ...file,\n      task_id: task.id,\n      file_index: index,\n      total_files: files.length,\n      file_type: fileType,\n      processing_mode: files.length > 1 ? 'batch' : 'single'\n    }\n  };\n});"
      },
      "id": "parse-task",
      "name": "Parse Task & Split Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [470, 300]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.file_type }}",
                    "rightValue": "pdf"
                  }
                ]
              },
              "outputIndex": 0
            },
            {
              "conditions": {
                "conditions": [
                  {
                    "leftValue": "={{ $json.file_type }}",
                    "rightValue": "tiff"
                  }
                ]
              },
              "outputIndex": 1
            }
          ]
        },
        "fallbackOutput": "extra"
      },
      "id": "route-by-format",
      "name": "Route by Format",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 2,
      "position": [690, 300]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4o",
        "options": {
          "maxTokens": 4096,
          "temperature": 0.1
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a tax document OCR expert. Extract all text and data from PDF documents. Handle multi-page PDFs by processing each page.\n\nRespond with JSON:\n{\n  \"document_type\": \"W-2|1099|Invoice|...\",\n  \"confidence\": 0.95,\n  \"pages\": [{\"page\": 1, \"content\": \"...\"}],\n  \"extracted_data\": {...},\n  \"ocr_confidence\": 0.92\n}"
            },
            {
              "role": "user",
              "content": [
                {
                  "type": "text",
                  "text": "Extract all data from this PDF document:"
                },
                {
                  "type": "image_url",
                  "image_url": {
                    "url": "={{ $json.base64_content ? 'data:' + $json.mime_type + ';base64,' + $json.base64_content : $json.file_url }}"
                  }
                }
              ]
            }
          ]
        }
      },
      "id": "process-pdf",
      "name": "Process PDF",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [910, 100],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAI API"
        }
      },
      "retryOnFail": true,
      "maxTries": 3
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4o",
        "options": {
          "maxTokens": 4096,
          "temperature": 0.1
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a tax document OCR expert. Extract all text and data from TIFF images. Handle multi-page TIFFs if applicable.\n\nRespond with JSON:\n{\n  \"document_type\": \"W-2|1099|Invoice|...\",\n  \"confidence\": 0.95,\n  \"extracted_data\": {...},\n  \"ocr_confidence\": 0.92\n}"
            },
            {
              "role": "user",
              "content": [
                {
                  "type": "text",
                  "text": "Extract all data from this TIFF document:"
                },
                {
                  "type": "image_url",
                  "image_url": {
                    "url": "={{ $json.base64_content ? 'data:' + $json.mime_type + ';base64,' + $json.base64_content : $json.file_url }}"
                  }
                }
              ]
            }
          ]
        }
      },
      "id": "process-tiff",
      "name": "Process TIFF",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [910, 300],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAI API"
        }
      },
      "retryOnFail": true,
      "maxTries": 3
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4o",
        "options": {
          "maxTokens": 4096,
          "temperature": 0.1
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a tax document OCR expert. Extract all text and data from images (JPEG, PNG, WebP).\n\nRespond with JSON:\n{\n  \"document_type\": \"W-2|1099|Invoice|...\",\n  \"confidence\": 0.95,\n  \"extracted_data\": {...},\n  \"ocr_confidence\": 0.92\n}"
            },
            {
              "role": "user",
              "content": [
                {
                  "type": "text",
                  "text": "Extract all data from this image:"
                },
                {
                  "type": "image_url",
                  "image_url": {
                    "url": "={{ $json.base64_content ? 'data:' + $json.mime_type + ';base64,' + $json.base64_content : $json.file_url }}"
                  }
                }
              ]
            }
          ]
        }
      },
      "id": "process-image",
      "name": "Process Image",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [910, 500],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAI API"
        }
      },
      "retryOnFail": true,
      "maxTries": 3
    },
    {
      "parameters": {
        "jsCode": "// Combine results from all format processors\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const inputData = item.json;\n  let ocrResult;\n  \n  try {\n    let responseText = inputData.message?.content || inputData.text || '{}';\n    if (responseText.includes('```json')) {\n      responseText = responseText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '');\n    }\n    ocrResult = JSON.parse(responseText.trim());\n  } catch (e) {\n    ocrResult = { document_type: 'Other', confidence: 0.5, extracted_data: {}, parse_error: e.message };\n  }\n  \n  // Get original input data\n  const originalInput = $('Parse Task & Split Files').all().find(i => \n    i.json.file_index === inputData.file_index || i.json.filename === inputData.filename\n  )?.json || {};\n  \n  results.push({\n    json: {\n      filename: originalInput.filename,\n      file_url: originalInput.file_url,\n      mime_type: originalInput.mime_type,\n      user_id: originalInput.user_id,\n      task_id: originalInput.task_id,\n      file_index: originalInput.file_index,\n      type: ocrResult.document_type,\n      extracted_data: ocrResult.extracted_data || {},\n      ocr_confidence: ocrResult.ocr_confidence,\n      classification_confidence: ocrResult.confidence\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "merge-results",
      "name": "Merge & Process Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1130, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/functions/v1/validate-document",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "document",
              "value": "={{ JSON.stringify({ filename: $json.filename, file_url: $json.file_url, mime_type: $json.mime_type, type: $json.type, extracted_data: $json.extracted_data, ocr_confidence: $json.ocr_confidence, classification_confidence: $json.classification_confidence }) }}"
            },
            {
              "name": "user_id",
              "value": "={{ $json.user_id }}"
            }
          ]
        },
        "options": {}
      },
      "id": "validate-store",
      "name": "Validate & Store",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1350, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "supabase-auth",
          "name": "Supabase Service Role"
        }
      },
      "retryOnFail": true,
      "maxTries": 3
    },
    {
      "parameters": {
        "jsCode": "// Aggregate all results for batch response\nconst items = $input.all();\nconst successful = items.filter(i => i.json.success === true);\nconst failed = items.filter(i => i.json.success !== true);\n\nreturn {\n  json: {\n    success: failed.length === 0,\n    total_processed: items.length,\n    successful: successful.length,\n    failed: failed.length,\n    document_ids: successful.map(i => i.json.document_id),\n    errors: failed.map(i => ({ filename: i.json.filename, errors: i.json.errors }))\n  }\n};"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1570, 300]
    }
  ],
  "connections": {
    "Workflow Input": {
      "main": [
        [
          {
            "node": "Parse Task & Split Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Task & Split Files": {
      "main": [
        [
          {
            "node": "Route by Format",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Format": {
      "main": [
        [
          {
            "node": "Process PDF",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process TIFF",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process PDF": {
      "main": [
        [
          {
            "node": "Merge & Process Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process TIFF": {
      "main": [
        [
          {
            "node": "Merge & Process Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Image": {
      "main": [
        [
          {
            "node": "Merge & Process Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge & Process Results": {
      "main": [
        [
          {
            "node": "Validate & Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Store": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "error-notifications"
  },
  "staticData": null,
  "tags": [
    {
      "name": "worker"
    },
    {
      "name": "document"
    }
  ],
  "triggerCount": 0,
  "pinData": {}
}
