{
  "name": "Tax Document Processing",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-document",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "document-upload"
    },
    {
      "parameters": {
        "jsCode": "// Extract file data from webhook\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const body = item.json.body || item.json;\n  \n  let fileData = {\n    filename: body.filename || 'unknown.png',\n    mime_type: body.mime_type || body.content_type || 'image/png',\n    file_url: body.file_url || null,\n    base64_content: body.base64_content || body.file_content || null,\n    user_id: body.user_id || null,\n    metadata: body.metadata || {}\n  };\n  \n  if (!fileData.base64_content && !fileData.file_url) {\n    throw new Error('Either base64_content or file_url is required');\n  }\n  \n  results.push({ json: fileData });\n}\n\nreturn results;"
      },
      "id": "parse-input",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [470, 300]
    },
    {
      "parameters": {
        "jsCode": "// Prepare OpenAI Vision API payload\nconst items = $input.all();\nconst results = [];\n\nconst systemPrompt = `You are a tax document processing expert. Analyze the provided image and:\n1. Identify the document type (W-2, 1099, 1099-MISC, 1099-INT, 1099-DIV, 1099-NEC, Invoice, Receipt, Bank Statement, or Other)\n2. Extract ALL text and data from the document\n3. Structure the extracted data appropriately for the document type\n\nRespond ONLY with valid JSON in this format:\n{\n  \"document_type\": \"W-2|1099|1099-MISC|1099-INT|1099-DIV|1099-NEC|Invoice|Receipt|Bank Statement|Other\",\n  \"confidence\": 0.95,\n  \"extracted_data\": {},\n  \"raw_text\": \"Full OCR text here\",\n  \"ocr_confidence\": 0.92\n}`;\n\nfor (const item of items) {\n  const data = item.json;\n  \n  const imageUrl = data.base64_content \n    ? 'data:' + data.mime_type + ';base64,' + data.base64_content \n    : data.file_url;\n  \n  results.push({\n    json: {\n      ...data,\n      openai_payload: {\n        model: 'gpt-4o',\n        messages: [\n          { role: 'system', content: systemPrompt },\n          { \n            role: 'user', \n            content: [\n              { type: 'text', text: 'Analyze this tax document and extract all information:' },\n              { type: 'image_url', image_url: { url: imageUrl } }\n            ]\n          }\n        ],\n        max_tokens: 4096,\n        temperature: 0.1\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "prepare-openai-payload",
      "name": "Prepare OpenAI Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [690, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.openai_payload) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "openai-vision",
      "name": "OpenAI GPT-4 Vision OCR",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [910, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "openai-credential",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse OpenAI response and prepare for storage\nconst items = $input.all();\nconst prevItems = $('Prepare OpenAI Payload').all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  const inputData = prevItems[i].json;\n  \n  let ocrResult;\n  try {\n    let responseText = item.json.choices?.[0]?.message?.content || '';\n    \n    if (responseText.includes('```json')) {\n      responseText = responseText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '');\n    } else if (responseText.includes('```')) {\n      responseText = responseText.replace(/```\\n?/g, '');\n    }\n    \n    ocrResult = JSON.parse(responseText.trim());\n  } catch (e) {\n    ocrResult = {\n      document_type: 'Other',\n      confidence: 0.5,\n      extracted_data: {},\n      raw_text: item.json.choices?.[0]?.message?.content || '',\n      ocr_confidence: 0.5,\n      parse_error: e.message\n    };\n  }\n  \n  results.push({\n    json: {\n      filename: inputData.filename,\n      file_url: inputData.file_url,\n      mime_type: inputData.mime_type,\n      user_id: inputData.user_id,\n      type: ocrResult.document_type,\n      extracted_data: ocrResult.extracted_data || {},\n      raw_text: ocrResult.raw_text,\n      ocr_confidence: ocrResult.ocr_confidence,\n      classification_confidence: ocrResult.confidence,\n      metadata: inputData.metadata\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "process-ocr-result",
      "name": "Process OCR Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1130, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://lkyixaippdmtjyiztuzw.supabase.co/rest/v1/documents",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "apikey",
              "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxreWl4YWlwcGRtdGp5aXp0dXp3Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2OTcwMjY4OSwiZXhwIjoyMDg1Mjc4Njg5fQ.nD4GhFIFXs-1qvdc42vAO1uumgTfGgiABsB9OgrOJHo"
            },
            {
              "name": "Prefer",
              "value": "return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  user_id: $json.user_id || null,\n  filename: $json.filename,\n  file_url: $json.file_url,\n  mime_type: $json.mime_type,\n  type: $json.type,\n  extracted_data: $json.extracted_data,\n  ocr_confidence: $json.ocr_confidence,\n  classification_confidence: $json.classification_confidence,\n  status: $json.classification_confidence >= 0.7 ? 'completed' : 'needs_review',\n  processed_at: new Date().toISOString()\n}) }}",
        "options": {}
      },
      "id": "store-in-supabase",
      "name": "Store in Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1570, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "supabase-credential",
          "name": "Supabase Service Key"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-success",
              "leftValue": "={{ $json[0]?.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-success",
      "name": "Check Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1790, 300]
    },
    {
      "parameters": {
        "jsCode": "// Prepare embedding payload from OCR results\nconst ocrData = $('Process OCR Result').first().json;\nconst storeResult = $('Store in Supabase').first().json;\nconst docId = Array.isArray(storeResult) ? storeResult[0]?.id : storeResult.id;\nconst docStatus = Array.isArray(storeResult) ? storeResult[0]?.status : storeResult.status;\n\n// Build content string from extracted data and raw text\nlet content = '';\n\n// Add raw text if available\nif (ocrData.raw_text) {\n  content += ocrData.raw_text + '\\n\\n';\n}\n\n// Add extracted data as searchable text\nif (ocrData.extracted_data && Object.keys(ocrData.extracted_data).length > 0) {\n  content += 'Extracted Data:\\n';\n  for (const [key, value] of Object.entries(ocrData.extracted_data)) {\n    if (value !== null && value !== undefined) {\n      content += `${key}: ${JSON.stringify(value)}\\n`;\n    }\n  }\n}\n\n// For now, skip embedding (requires API setup)\nreturn {\n  json: {\n    document_id: docId,\n    document_type: ocrData.type,\n    status: docStatus,\n    skip_embedding: true,\n    content_length: content.length\n  }\n};"
      },
      "id": "prepare-embedding-payload",
      "name": "Prepare Embedding Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2010, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-has-content",
              "leftValue": "={{ $json.skip_embedding }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "has-content",
      "name": "Has Content",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2230, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://lkyixaippdmtjyiztuzw.supabase.co/functions/v1/store-embedding",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "apikey",
              "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxreWl4YWlwcGRtdGp5aXp0dXp3Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2OTcwMjY4OSwiZXhwIjoyMDg1Mjc4Njg5fQ.nD4GhFIFXs-1qvdc42vAO1uumgTfGgiABsB9OgrOJHo"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.embedding_payload) }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "store-embedding",
      "name": "Store Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2450, 100],
      "credentials": {
        "httpHeaderAuth": {
          "id": "supabase-credential",
          "name": "Supabase Service Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare final response with embedding info\nconst items = $input.all();\nconst prevItems = $('Prepare Embedding Payload').all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const embeddingResult = items[i].json;\n  const prepData = prevItems[i].json;\n  \n  results.push({\n    json: {\n      document_id: prepData.document_id,\n      document_type: prepData.document_type,\n      status: prepData.status,\n      embeddings_stored: embeddingResult.embeddings_stored || 0,\n      embedding_success: embeddingResult.success || false\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "process-embedding-result",
      "name": "Process Embedding Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2670, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, document_id: $json.document_id, type: $json.document_type, status: $json.status, embeddings_stored: $json.embeddings_stored || 0 }) }}"
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2890, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, document_id: $json.document_id, type: $json.document_type, status: $json.status, embeddings_stored: 0, note: 'No content for embedding' }) }}"
      },
      "id": "success-no-embedding",
      "name": "Success No Embedding",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2450, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.error || $json.errors || 'Document processing failed' }) }}",
        "options": {
          "responseCode": 422
        }
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2010, 400]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Parse Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Input": {
      "main": [
        [
          {
            "node": "Prepare OpenAI Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare OpenAI Payload": {
      "main": [
        [
          {
            "node": "OpenAI GPT-4 Vision OCR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI GPT-4 Vision OCR": {
      "main": [
        [
          {
            "node": "Process OCR Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process OCR Result": {
      "main": [
        [
          {
            "node": "Store in Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Supabase": {
      "main": [
        [
          {
            "node": "Check Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Success": {
      "main": [
        [
          {
            "node": "Prepare Embedding Payload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Embedding Payload": {
      "main": [
        [
          {
            "node": "Has Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Content": {
      "main": [
        [
          {
            "node": "Store Embedding",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Success No Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Embedding": {
      "main": [
        [
          {
            "node": "Process Embedding Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Embedding Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "pinData": {}
}
